#!/usr/bin/env python
#
# A gimp launcher/monitor that saves the current session on the fly.
#
# - uses my own fork of gimp-2.8:
#   https://github.com/soimort/gimp
# - reads/writes in mur format: https://github.com/soimort/mur
# - dependencies: python (3.7+), watchdog

import argparse
from os import environ, path
from pathlib import Path
import select
import subprocess
import sys
import tempfile
import time
from urllib.parse import unquote
import xml.etree.ElementTree as ET

import watchdog
from watchdog.observers import Observer


# ANSI escape code
RESET = 0
BOLD = 1
UNDERLINE = 4
NEGATIVE = 7
NO_BOLD = 21
NO_UNDERLINE = 24
POSITIVE = 27
BLACK = 30
RED = 31
GREEN = 32
YELLOW = 33
BLUE = 34
MAGENTA = 35
CYAN = 36
LIGHT_GRAY = 37
DEFAULT = 39
BLACK_BACKGROUND = 40
RED_BACKGROUND = 41
GREEN_BACKGROUND = 42
YELLOW_BACKGROUND = 43
BLUE_BACKGROUND = 44
MAGENTA_BACKGROUND = 45
CYAN_BACKGROUND = 46
LIGHT_GRAY_BACKGROUND = 47
DEFAULT_BACKGROUND = 49

def print_with_colors(text, *colors):
    """Print text with colors."""
    print("\33[{}m{content}\33[{}m".format(
        ";".join([str(color) for color in colors]), RESET, content=text))

def print_inline_with_colors(text, *colors):
    """Print inline text with colors."""
    print("\33[{}m{content}\33[{}m".format(
        ";".join([str(color) for color in colors]), RESET, content=text), end='', flush=True)


def read_mur_file(f):
    """Read from a session file and return a list of documents."""

    s = []
    is_reading_yaml = False
    for line in list(f):
        if is_reading_yaml:
            text = line.rstrip()
            if text == '---':
                is_reading_yaml = False  # YAML front matter ends
            else:
                pass  # TODO: read YAML metadata
        else:
            text = line.strip()  # strip indentation as well

            # skip empty lines and comments
            if text == '' or text.startswith('# '):
                continue

            if text == '---':
                if not s:
                    is_reading_yaml = True  # YAML front matter begins
                else:
                    break  # end of valid document

            elif text == '***':
                # workspace delimiter
                continue

            elif text.startswith('* ') or text.startswith('/') or text.startswith('sftp://'):
                if text.startswith('* '):
                    # bulleted URL entry
                    loc = text[2:]
                else:
                    loc = text
                s.append(loc)

            else:
                # plain text line
                continue
    return s


def write_mur_file(f, s, debug=True):
    """Write to a session file."""

    mur = '# THIS FILE IS AUTO-GENERATED BY A MONITOR. DO NOT EDIT!\n\n'
    mur += 'default\n'
    for i in s:
        mur += i + '\n'

    f.write(mur)


def read_recently_used(xbel_filename):
    """Read from recently-used.xbel and return a list of documents recently used by GIMP."""

    r = []
    tree = ET.parse(xbel_filename)
    root = tree.getroot()
    for child in root:
        if child.tag == 'bookmark':
            mime_type = ''
            gimp_used = False
            href = child.attrib['href']
            for k in child[0][0]:
                if k.tag == '{http://www.freedesktop.org/standards/shared-mime-info}mime-type':
                    mime_type = k.attrib['type']
                if k.tag == '{http://www.freedesktop.org/standards/desktop-bookmarks}applications':
                    for l in k:
                        if l.attrib['name'] == 'GNU Image Manipulation Program':
                            gimp_used = True
            if gimp_used and mime_type == 'image/xcf':
                if unquote(href)[:7] == 'file://':
                    r.append(unquote(href)[7:])
    return r


def on_modified(event):
    global xbel_filename, s, u
    if event.event_type == 'modified':
        u_new = read_recently_used(xbel_filename)
        new_documents = list(set(u_new) - set(u))
        u = u_new

        for new_document in new_documents:
            if new_document not in s:
                s.append(new_document)
                #if args.debug:
                print_with_colors("\nnewly created document: %s" % new_document, BLUE, BOLD)
                # FIXME: we should save immediately


home = Path.home()
config_dir = environ.get('XDG_CONFIG_HOME') or '%s/.config' % home
local_share_dir = environ.get('XDG_DATA_HOME') or '%s/.local/share' % home
xbel_filename = '%s/recently-used.xbel' % local_share_dir

s = []
u = read_recently_used(xbel_filename)


def main():

    # parse arguments
    parser = argparse.ArgumentParser(prog='gimp-launcher', usage='gimp-launcher SESSION',
                                     description='',
                                     add_help=True)
    parser.add_argument('--debug', action='store_true', default=False,
                        help='show detailed information for debugging')
    parser.add_argument('--no-rlwrap', action='store_true', default=False,
                        help='do not invoke rlwrap')
    parser.add_argument('SESSION', nargs='?', help=argparse.SUPPRESS)
    args = parser.parse_args()

    # invoke rlwrap if possible
    if not args.no_rlwrap:
        try:
            subprocess.run(['rlwrap', '--version'], capture_output=True)
        except FileNotFoundError:
            print_with_colors('[warning] rlwrap not found', BOLD, YELLOW)
        else:
            wrapped_args = sys.argv + ['--no-rlwrap']
            if args.debug:
                print_with_colors('[info] invoking rlwrap on: %s' % wrapped_args, BOLD, GREEN)
            subprocess.run(['rlwrap'] + wrapped_args)
            return

    if args.SESSION is None:
        # create temporary session file
        with tempfile.NamedTemporaryFile(mode='w', encoding='utf-8', delete=False) as f:
            f.write('default\n')
            session_filename = f.name
        print_with_colors('[warning] creating temp session file "%s"' % session_filename, BOLD, YELLOW)
    else:
        # use specified session file
        session_filename = args.SESSION

    # read session file
    s_init = []
    try:
        with open(session_filename) as f:
            s_init = read_mur_file(f)
    except FileNotFoundError:
        session_filename = path.join(Path.home(), '%s.mur' % session_filename)
        try:
            with open(session_filename) as f:
                s_init = read_mur_file(f)
        except FileNotFoundError:
            # create new session file
            with open(session_filename, 'w') as f:
                f.write("# THIS FILE IS AUTO-GENERATED BY A MONITOR. DO NOT EDIT!\n\n")
                f.write("default\n")
            with open(session_filename) as f:
                s_init = read_mur_file(f)

    # filter nonexistent documents
    s_invalid = [i for i in s_init if not path.isfile(i)]
    s_init = [i for i in s_init if path.isfile(i)]
    s_init = list(dict.fromkeys(s_init))  # remove duplicates
    if s_invalid:
        print_with_colors("[panic] some initial documents not found: %s" % s_invalid, RED, BOLD)
    print_with_colors("initial documents: %s" % s_init, BLUE)

    # open gimp process
    procs = []
    params = ['gimp-2.8']
    params.extend(s_init)
    if args.debug:
        procs.append(subprocess.Popen(params, stdout=subprocess.PIPE))
    else:  # suppress stderr
        procs.append(subprocess.Popen(params, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL))

    # watch recently-used.xbel for recently created documents
    event_handler = watchdog.events.PatternMatchingEventHandler(patterns=['recently-used.xbel'])
    event_handler.on_modified = on_modified
    observer = Observer()
    observer.schedule(event_handler, local_share_dir, recursive=False)
    observer.start()

    # main loop
    is_loading_finished = len(s) == len(s_init)  # True if all initial documents are loaded in gimp
    flag = False  # False when waiting for user input, True when waiting for process output
    last_proc_ts = time.time()
    last_trying_to_close = ''
    while True:
        try:
            if sys.stdin in select.select([sys.stdin], [], [], 0)[0]:
                # non-blocking read of user input
                line = sys.stdin.readline()
                if line:
                    text = line.rstrip()

                    if text == 's':
                        print(s)

                    elif text == 'show':
                        for i in s:
                            print(i)

                    elif text == 's_init':
                        print(s_init)

                    elif text == 'filename':
                        print(session_filename)

                    elif text == 'save':
                        with open(session_filename, 'w') as f:
                            write_mur_file(f, s, debug=False)
                        print('session saved: %s' % session_filename)

                    elif text == 'exit':
                        with open(session_filename, 'w') as f:
                            write_mur_file(f, s, debug=False)
                        print('session saved: %s' % session_filename)

                        print_with_colors('[warning] closing monitor...', BOLD, YELLOW)
                        exit(0)

                    elif text == 'help':
                        print('s\t\t Show all documents in the session')
                        print('show\t\t Show all documents in the session, line by line')
                        print('s_init\t\t Show initial documents from the session file')
                        print('filename\t Show the session filename')
                        print('save\t\t Save to the session file')
                        print('exit\t\t Save to the session file and exit')

                    elif text:
                        print_with_colors('[error] unrecognized command: %s' % text, YELLOW)

                    print_inline_with_colors('> ', BOLD)  # print prompt again
                else:
                    # an empty line means stdin has been closed (caused by Ctrl-D)
                    print_with_colors('\n[warning] stdin has been closed. closing monitor...', BOLD, YELLOW)
                    break

            # FIXME: with sleep() there's always some delay until new output ready
            for proc_stdout in select.select([proc.stdout for proc in procs], [], [], 0)[0]:
                # non-blocking read from external process
                line = proc_stdout.readline()
                if line:
                    text = str(line, encoding='utf-8').rstrip()

                    if text[:3] == ">>>":  # recognized log
                        try:
                            action, info = text[4:].split(': ')
                        except:
                            action, info = text[4:], ''  # empty info

                        if not flag: print()  # new line after prompt
                        print_with_colors(text[4:], GREEN)

                        if action == "gui_display_create":
                            if info != '(null)':
                                if info[:7] == 'file://':
                                    loc = unquote(info)[7:]
                                    if loc not in s:
                                        s.append(loc)
                                    if args.debug:
                                        print_with_colors("loaded document: %s" % loc, BLUE, BOLD)
                                    if len(s) >= len(s_init):
                                        is_loading_finished = True
                                        if args.debug:
                                            print_with_colors("loading finished", BLUE, BOLD)
                                else:
                                    print_with_colors('[panic] opened a document which is not a file: %s' %
                                                      info, BOLD, RED)

                        elif action == "gimp_display_shell_close":
                            if info[:7] == 'file://':
                                last_trying_to_close = unquote(info)[7:]
                            else:
                                last_trying_to_close = info

                        elif action == "gimp_display_close!":
                            # FIXME: there should be no lag following gimp_display_shell_close
                            if last_trying_to_close != '(null)':
                                try:
                                    s.remove(last_trying_to_close)  # FIXME: this always removes the first one
                                    if args.debug:
                                        print_with_colors("closed document: %s" % last_trying_to_close, BLUE, BOLD)
                                except ValueError:
                                    print_with_colors('[panic] closed a document which is not in the session: %s' %
                                                      last_trying_to_close, BOLD, RED)

                        if is_loading_finished:
                            if args.debug:
                                print_with_colors("s: %s" % s, BLUE)

                            with open(session_filename, 'w') as f:
                                write_mur_file(f, s, debug=args.debug)

                        flag, last_proc_ts = True, time.time()
                else:
                    # an empty line means nothing (???)
                    pass

            current_ts = time.time()
            # when waiting for process output but last output has been a while
            if flag and current_ts - last_proc_ts > .25:
                print_inline_with_colors('> ', BOLD)  # print prompt
                flag = False  # waiting for user input

            if is_loading_finished:
                time.sleep(1.0)  # TODO: what is a proper sleeping time?

        except KeyboardInterrupt:
            print_with_colors('\n[warning] Ctrl-C pressed. brutally terminating...', BOLD, YELLOW)
            break
        except Exception as err:
            # child process may produce invalid output to parse, pass rather than crash
            print_with_colors('[error] exception while parsing the log:', YELLOW)
            print_with_colors(err, YELLOW)
            pass

    observer.stop()
    observer.join()
    return


if __name__ == '__main__':
    main()
